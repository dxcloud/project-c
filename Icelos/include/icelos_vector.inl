#ifndef ICELOS_VECTOR_INL
#define ICELOS_VECTOR_INL

namespace icelos
{

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
template <typename T>
inline Vector<T>::Vector():
  x(static_cast<T>(0)),
  y(static_cast<T>(0))
{
  // nothing to do
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
template <typename T>
inline Vector<T>::Vector(T x, T y)
{
  Vector<T>::x = x;
  Vector<T>::y = y;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
template <typename T>
inline Vector<T>::Vector(const Vector<T>& vector):
  x(vector.x),
  y(vector.y)
{
  // nothing to do
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
template <typename T>
inline Vector<T>& Vector<T>::operator=(const Vector<T>& vector)
{
  x = vector.x;
  y = vector.y;
  return *this;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
template <typename T>
inline Vector<T> Vector<T>::operator+(const Vector<T>& vector) const
{
  return Vector<T>(x + vector.x, y + vector.y);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
template <typename T>
inline Vector<T> Vector<T>::operator-(const Vector<T>& vector) const
{
  return Vector<T>(x - vector.x, y - vector.y);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
template <typename T>
template <typename U>
inline Vector<T> Vector<T>::operator*(U scalar) const
{
  return Vector<T>(scalar * x, scalar * y);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
template <typename T>
template <typename U>
inline Vector<T> Vector<T>::operator/(U scalar) const
{
  return Vector<T>(x / scalar, y / scalar);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
template <typename T>
inline Vector<T>& Vector<T>::operator+=(const Vector<T>& vector)
{
  x += vector.x;
  y += vector.y;
  return *this;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
template <typename T>
inline Vector<T>& Vector<T>::operator-=(const Vector<T>& vector)
{
  x -= vector.x;
  y -= vector.y;
  return *this;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
template <typename T>
template <typename U>
inline Vector<T>& Vector<T>::operator*=(U scalar)
{
  x = static_cast<T>(x * scalar);
  y = static_cast<T>(y * scalar);
  return (*this);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
template <typename T>
template <typename U>
inline Vector<T>& Vector<T>::operator/=(U scalar)
{
  x = static_cast<T>(x / scalar);
  y = static_cast<T>(y / scalar);
  return (*this);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
template <typename T>
inline Vector<T> Vector<T>::operator!() const
{
  return Vector<T>(-x, y);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
template <typename T>
inline Vector<T> Vector<T>::operator~() const
{
  return Vector<T>(x, -y);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
template <typename T>
inline Vector<T> Vector<T>::operator-() const
{
  return Vector<T>(-x, -y);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
template <typename T>
inline T Vector<T>::dot(const Vector<T>& vector) const
{
  return ((x * vector.x) + (y * vector.y));
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
template <typename T>
inline T Vector<T>::cross(const Vector<T>& vector) const
{
  return ((x * vector.y) - (y * vector.x));
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
template <typename T>
inline T Vector<T>::norm2() const
{
  return ((x * x) + (y * y));
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
template <typename T>
inline Vector<T> operator*(T scalar, const Vector<T>& vector)
{
  return Vector<T>(scalar * vector.x, scalar * vector.y);
}

} // namespace icelos

#endif // ICELOS_VECTOR_INL

