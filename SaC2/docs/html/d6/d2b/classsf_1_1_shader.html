<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>SaC2: sf::Shader Class Reference</title>

<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">SaC2
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">2D Game Engine</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('d6/d2b/classsf_1_1_shader.html','../../');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">sf::Shader Class Reference<div class="ingroups"><a class="el" href="../../d6/de0/group__graphics.html">Graphics module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="sf::Shader" --><!-- doxytag: inherits="sf::GlResource,sf::NonCopyable" -->
<p><a class="el" href="../../d6/d2b/classsf_1_1_shader.html" title="Shader class (vertex and fragment)">Shader</a> class (vertex and fragment)  
 <a href="../../d6/d2b/classsf_1_1_shader.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d2/d73/_shader_8hpp_source.html">Shader.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sf::Shader:</div>
<div class="dyncontent">
<div class="center"><img src="../../d0/d98/classsf_1_1_shader__inherit__graph.png" border="0" usemap="#sf_1_1_shader_inherit__map" alt="Inheritance graph"/></div>
<map name="sf_1_1_shader_inherit__map" id="sf_1_1_shader_inherit__map">
<area shape="rect" id="node2" href="../../df/d6f/classsf_1_1_gl_resource.html" title="Base class for classes that require an OpenGL context." alt="" coords="5,5,115,35"/><area shape="rect" id="node4" href="../../d9/df6/classsf_1_1_non_copyable.html" title="Utility class that makes any derived class non&#45;copyable." alt="" coords="139,5,259,35"/></map>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for sf::Shader:</div>
<div class="dyncontent">
<div class="center"><img src="../../de/de4/classsf_1_1_shader__coll__graph.png" border="0" usemap="#sf_1_1_shader_coll__map" alt="Collaboration graph"/></div>
<map name="sf_1_1_shader_coll__map" id="sf_1_1_shader_coll__map">
<area shape="rect" id="node2" href="../../df/d6f/classsf_1_1_gl_resource.html" title="Base class for classes that require an OpenGL context." alt="" coords="5,5,115,35"/><area shape="rect" id="node4" href="../../d9/df6/classsf_1_1_non_copyable.html" title="Utility class that makes any derived class non&#45;copyable." alt="" coords="139,5,259,35"/><area shape="rect" id="node6" href="../../d0/d0d/structsf_1_1_shader_1_1_current_texture_type.html" title="Special type/value that can be passed to setParameter, and that represents the texture of the object ..." alt="" coords="283,5,488,35"/></map>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>

<p><a href="../../d1/d29/classsf_1_1_shader-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d0d/structsf_1_1_shader_1_1_current_texture_type.html">CurrentTextureType</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Special type/value that can be passed to setParameter, and that represents the texture of the object being drawn.  <a href="../../d0/d0d/structsf_1_1_shader_1_1_current_texture_type.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#afaa1aa65e5de37b74d047da9def9f9b3">Type</a> { <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#afaa1aa65e5de37b74d047da9def9f9b3a8718008f827eb32e29bbdd1791c62dce">Vertex</a>, 
<a class="el" href="../../d6/d2b/classsf_1_1_shader.html#afaa1aa65e5de37b74d047da9def9f9b3ace6e88eec3a56b2e55ee3c8e64e9b89a">Fragment</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of shaders.  <a href="../../d6/d2b/classsf_1_1_shader.html#afaa1aa65e5de37b74d047da9def9f9b3">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a1d7f28f26b4122959fcafec871c2c3c5">Shader</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a1d7f28f26b4122959fcafec871c2c3c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a4bac6cc8b046ecd8fb967c145a2380e6">~Shader</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a4bac6cc8b046ecd8fb967c145a2380e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a053a5632848ebaca2fcd8ba29abe9e6e">loadFromFile</a> (const std::string &amp;filename, <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#afaa1aa65e5de37b74d047da9def9f9b3">Type</a> type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load either the vertex or fragment shader from a file.  <a href="#a053a5632848ebaca2fcd8ba29abe9e6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#ac9d7289966fcef562eeb92271c03e3dc">loadFromFile</a> (const std::string &amp;vertexShaderFilename, const std::string &amp;fragmentShaderFilename)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load both the vertex and fragment shaders from files.  <a href="#ac9d7289966fcef562eeb92271c03e3dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#ac92d46bf71dff2d791117e4e472148aa">loadFromMemory</a> (const std::string &amp;shader, <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#afaa1aa65e5de37b74d047da9def9f9b3">Type</a> type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load either the vertex or fragment shader from a source code in memory.  <a href="#ac92d46bf71dff2d791117e4e472148aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#ae34e94070d7547a890166b7993658a9b">loadFromMemory</a> (const std::string &amp;vertexShader, const std::string &amp;fragmentShader)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load both the vertex and fragment shaders from source codes in memory.  <a href="#ae34e94070d7547a890166b7993658a9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a2ee1b130c0606e4f8bcdf65c1efc2a53">loadFromStream</a> (<a class="el" href="../../d3/d3f/classsf_1_1_input_stream.html">InputStream</a> &amp;stream, <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#afaa1aa65e5de37b74d047da9def9f9b3">Type</a> type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load either the vertex or fragment shader from a custom stream.  <a href="#a2ee1b130c0606e4f8bcdf65c1efc2a53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a3b7958159ffb5596c4babc3052e35465">loadFromStream</a> (<a class="el" href="../../d3/d3f/classsf_1_1_input_stream.html">InputStream</a> &amp;vertexShaderStream, <a class="el" href="../../d3/d3f/classsf_1_1_input_stream.html">InputStream</a> &amp;fragmentShaderStream)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load both the vertex and fragment shaders from custom streams.  <a href="#a3b7958159ffb5596c4babc3052e35465"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a47e4dd78f0752ae08664b4ee616db1cf">setParameter</a> (const std::string &amp;name, float x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a float parameter of the shader.  <a href="#a47e4dd78f0752ae08664b4ee616db1cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#ab8d379f40810b8e3eadebee81aedd231">setParameter</a> (const std::string &amp;name, float x, float y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a 2-components vector parameter of the shader.  <a href="#ab8d379f40810b8e3eadebee81aedd231"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a7e36e044d6b8adca8339f40c5a4b1801">setParameter</a> (const std::string &amp;name, float x, float y, float z)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a 3-components vector parameter of the shader.  <a href="#a7e36e044d6b8adca8339f40c5a4b1801"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#aeb468f1bc2d26750b96b74f1e19027fb">setParameter</a> (const std::string &amp;name, float x, float y, float z, float w)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a 4-components vector parameter of the shader.  <a href="#aeb468f1bc2d26750b96b74f1e19027fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a3ac473ece2c6fa26dc5032c07fd7288e">setParameter</a> (const std::string &amp;name, const <a class="el" href="../../d4/dd0/namespacesf.html#acf03098c2577b869e2fa6836cc48f1a0">Vector2f</a> &amp;vector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a 2-components vector parameter of the shader.  <a href="#a3ac473ece2c6fa26dc5032c07fd7288e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a87d4a0c6dc70ae68aecc0dda3f343c07">setParameter</a> (const std::string &amp;name, const <a class="el" href="../../d4/dd0/namespacesf.html#af97357d7d32e7d6a700d03be2f3b4811">Vector3f</a> &amp;vector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a 3-components vector parameter of the shader.  <a href="#a87d4a0c6dc70ae68aecc0dda3f343c07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#aa8618119ed4399df3fd33e78ee96b4fc">setParameter</a> (const std::string &amp;name, const <a class="el" href="../../d8/de5/classsf_1_1_color.html">Color</a> &amp;color)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a color parameter of the shader.  <a href="#aa8618119ed4399df3fd33e78ee96b4fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a39c387cc30e249b22a0c478703b8cc9a">setParameter</a> (const std::string &amp;name, const <a class="el" href="../../d4/d49/classsf_1_1_transform.html">sf::Transform</a> &amp;transform)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a matrix parameter of the shader.  <a href="#a39c387cc30e249b22a0c478703b8cc9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a7f58ab5c0a1084f238dfcec86602daa1">setParameter</a> (const std::string &amp;name, const <a class="el" href="../../d4/d96/classsf_1_1_texture.html">Texture</a> &amp;texture)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a texture parameter of the shader.  <a href="#a7f58ab5c0a1084f238dfcec86602daa1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#af06b4cba0bab915fa01032b063909044">setParameter</a> (const std::string &amp;name, <a class="el" href="../../d0/d0d/structsf_1_1_shader_1_1_current_texture_type.html">CurrentTextureType</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a texture parameter of the shader.  <a href="#af06b4cba0bab915fa01032b063909044"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a09778f78afcbeb854d608c8dacd8ea30">bind</a> (const <a class="el" href="../../d6/d2b/classsf_1_1_shader.html">Shader</a> *shader)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a shader for rendering.  <a href="#a09778f78afcbeb854d608c8dacd8ea30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#ad22474690bafe4a305c1b9826b1bd86a">isAvailable</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell whether or not the system supports shaders.  <a href="#ad22474690bafe4a305c1b9826b1bd86a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d0/d0d/structsf_1_1_shader_1_1_current_texture_type.html">CurrentTextureType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#ac84c7953eec2e19358ea6e2cc5385b8d">CurrentTexture</a></td></tr>
<tr><td colspan="2"><h2><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; int, const <br class="typebreak"/>
<a class="el" href="../../d4/d96/classsf_1_1_texture.html">Texture</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a9a60c773571550fd54a394d4ce83f4a3">TextureTable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <br class="typebreak"/>
int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a6934cc8c84c37d55db0a126ddb274abf">ParamTable</a></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a500c8e3b0901bdb272175467fdda80b9">compile</a> (const char *vertexShaderCode, const char *fragmentShaderCode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile the shader(s) and create the program.  <a href="#a500c8e3b0901bdb272175467fdda80b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#afc5f4c744f76e5c4cfa74d222b6eab11">bindTextures</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind all the textures used by the shader.  <a href="#afc5f4c744f76e5c4cfa74d222b6eab11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a8e14d868ccf4d464a155eec58570434a">getParamLocation</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the location ID of a shader parameter.  <a href="#a8e14d868ccf4d464a155eec58570434a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a72169743cfd7206fd49759f705a15466">m_shaderProgram</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenGL identifier for the program.  <a href="#a72169743cfd7206fd49759f705a15466"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a5d7b43495def6cc6bd91b6c5d167a485">m_currentTexture</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Location of the current texture in the shader.  <a href="#a5d7b43495def6cc6bd91b6c5d167a485"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a9a60c773571550fd54a394d4ce83f4a3">TextureTable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a3daecf04a0045a1d7445959432b5a52f">m_textures</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d4/d96/classsf_1_1_texture.html" title="Image living on the graphics card that can be used for drawing.">Texture</a> variables in the shader, mapped to their location.  <a href="#a3daecf04a0045a1d7445959432b5a52f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a6934cc8c84c37d55db0a126ddb274abf">ParamTable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a856d4fd949fcd1c0a54c77d7fb8f0084">m_params</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters location cache.  <a href="#a856d4fd949fcd1c0a54c77d7fb8f0084"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="../../d6/d2b/classsf_1_1_shader.html" title="Shader class (vertex and fragment)">Shader</a> class (vertex and fragment) </p>
<p>Shaders are programs written using a specific language, executed directly by the graphics card and allowing to apply real-time operations to the rendered entities.</p>
<p>There are two kinds of shaders: </p>
<ul>
<li><a class="el" href="../../d9/daf/classsf_1_1_vertex.html" title="Define a point with color and texture coordinates.">Vertex</a> shaders, that process vertices </li>
<li>Fragment (pixel) shaders, that process pixels</li>
</ul>
<p>A <a class="el" href="../../d6/d2b/classsf_1_1_shader.html" title="Shader class (vertex and fragment)">sf::Shader</a> can be composed of either a vertex shader alone, a fragment shader alone, or both combined (see the variants of the load functions).</p>
<p>Shaders are written in GLSL, which is a C-like language dedicated to OpenGL shaders. You'll probably need to learn its basics before writing your own shaders for SFML.</p>
<p>Like any C/C++ program, a shader has its own variables that you can set from your C++ application. <a class="el" href="../../d6/d2b/classsf_1_1_shader.html" title="Shader class (vertex and fragment)">sf::Shader</a> handles 5 different types of variables: </p>
<ul>
<li>floats </li>
<li>vectors (2, 3 or 4 components) </li>
<li>colors </li>
<li>textures </li>
<li>transforms (matrices)</li>
</ul>
<p>The value of the variables can be changed at any time with the various overloads of the setParameter function: </p>
<div class="fragment"><pre class="fragment"> shader.setParameter(<span class="stringliteral">&quot;offset&quot;</span>, 2.f);
 shader.setParameter(<span class="stringliteral">&quot;point&quot;</span>, 0.5f, 0.8f, 0.3f);
 shader.setParameter(<span class="stringliteral">&quot;color&quot;</span>, <a class="code" href="../../d8/de5/classsf_1_1_color.html" title="Utility class for manpulating RGBA colors.">sf::Color</a>(128, 50, 255));
 shader.setParameter(<span class="stringliteral">&quot;matrix&quot;</span>, transform); <span class="comment">// transform is a sf::Transform</span>
 shader.setParameter(<span class="stringliteral">&quot;overlay&quot;</span>, texture); <span class="comment">// texture is a sf::Texture</span>
 shader.setParameter(<span class="stringliteral">&quot;texture&quot;</span>, <a class="code" href="../../d6/d2b/classsf_1_1_shader.html#ac84c7953eec2e19358ea6e2cc5385b8d">sf::Shader::CurrentTexture</a>);
</pre></div><p>The special <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#ac84c7953eec2e19358ea6e2cc5385b8d">Shader::CurrentTexture</a> argument maps the given texture variable to the current texture of the object being drawn (which cannot be known in advance).</p>
<p>To apply a shader to a drawable, you must pass it as an additional parameter to the Draw function: </p>
<div class="fragment"><pre class="fragment"> window.draw(sprite, &amp;shader);
</pre></div><p>... which is in fact just a shortcut for this: </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="../../d9/d68/classsf_1_1_render_states.html" title="Define the states used for drawing to a RenderTarget.">sf::RenderStates</a> states;
 states.<a class="code" href="../../d9/d68/classsf_1_1_render_states.html#ad4f79ecdd0c60ed0d24fbe555b221bd8" title="Shader.">shader</a> = &amp;shader;
 window.draw(sprite, states);
</pre></div><p>In the code above we pass a pointer to the shader, because it may be null (which means "no shader").</p>
<p>Shaders can be used on any drawable, but some combinations are not interesting. For example, using a vertex shader on a <a class="el" href="../../d2/d70/classsf_1_1_sprite.html" title="Drawable representation of a texture, with its own transformations, color, etc.">sf::Sprite</a> is limited because there are only 4 vertices, the sprite would have to be subdivided in order to apply wave effects. Another bad example is a fragment shader with <a class="el" href="../../d6/ddb/classsf_1_1_text.html" title="Graphical text that can be drawn to a render target.">sf::Text</a>: the texture of the text is not the actual text that you see on screen, it is a big texture containing all the characters of the font in an arbitrary order; thus, texture lookups on pixels other than the current one may not give you the expected result.</p>
<p>Shaders can also be used to apply global post-effects to the current contents of the target (like the old sf::PostFx class in SFML 1). This can be done in two different ways: </p>
<ul>
<li>draw everything to a <a class="el" href="../../df/d0c/classsf_1_1_render_texture.html" title="Target for off-screen 2D rendering into a texture.">sf::RenderTexture</a>, then draw it to the main target using the shader </li>
<li>draw everything directly to the main target, then use sf::Texture::update(Window&amp;) to copy its contents to a texture and draw it to the main target using the shader</li>
</ul>
<p>The first technique is more optimized because it doesn't involve retrieving the target's pixels to system memory, but the second one doesn't impact the rendering process and can be easily inserted anywhere without impacting all the code.</p>
<p>Like <a class="el" href="../../d4/d96/classsf_1_1_texture.html" title="Image living on the graphics card that can be used for drawing.">sf::Texture</a> that can be used as a raw OpenGL texture, <a class="el" href="../../d6/d2b/classsf_1_1_shader.html" title="Shader class (vertex and fragment)">sf::Shader</a> can also be used directly as a raw shader for custom OpenGL geometry. </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="../../d6/d2b/classsf_1_1_shader.html#a09778f78afcbeb854d608c8dacd8ea30" title="Bind a shader for rendering.">sf::Shader::bind</a>(&amp;shader);
 ... render OpenGL geometry ...
 <a class="code" href="../../d6/d2b/classsf_1_1_shader.html#a09778f78afcbeb854d608c8dacd8ea30" title="Bind a shader for rendering.">sf::Shader::bind</a>(NULL);
</pre></div> </div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a6934cc8c84c37d55db0a126ddb274abf"></a><!-- doxytag: member="sf::Shader::ParamTable" ref="a6934cc8c84c37d55db0a126ddb274abf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, int&gt; <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a6934cc8c84c37d55db0a126ddb274abf">sf::Shader::ParamTable</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9a60c773571550fd54a394d4ce83f4a3"></a><!-- doxytag: member="sf::Shader::TextureTable" ref="a9a60c773571550fd54a394d4ce83f4a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;int, const <a class="el" href="../../d4/d96/classsf_1_1_texture.html">Texture</a>*&gt; <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a9a60c773571550fd54a394d4ce83f4a3">sf::Shader::TextureTable</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="afaa1aa65e5de37b74d047da9def9f9b3"></a><!-- doxytag: member="sf::Shader::Type" ref="afaa1aa65e5de37b74d047da9def9f9b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#afaa1aa65e5de37b74d047da9def9f9b3">sf::Shader::Type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Types of shaders. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="afaa1aa65e5de37b74d047da9def9f9b3a8718008f827eb32e29bbdd1791c62dce"></a><!-- doxytag: member="Vertex" ref="afaa1aa65e5de37b74d047da9def9f9b3a8718008f827eb32e29bbdd1791c62dce" args="" -->Vertex</em>&nbsp;</td><td>
<p><a class="el" href="../../d9/daf/classsf_1_1_vertex.html" title="Define a point with color and texture coordinates.">Vertex</a> shader. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afaa1aa65e5de37b74d047da9def9f9b3ace6e88eec3a56b2e55ee3c8e64e9b89a"></a><!-- doxytag: member="Fragment" ref="afaa1aa65e5de37b74d047da9def9f9b3ace6e88eec3a56b2e55ee3c8e64e9b89a" args="" -->Fragment</em>&nbsp;</td><td>
<p>Fragment (pixel) shader. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1d7f28f26b4122959fcafec871c2c3c5"></a><!-- doxytag: member="sf::Shader::Shader" ref="a1d7f28f26b4122959fcafec871c2c3c5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a1d7f28f26b4122959fcafec871c2c3c5">sf::Shader::Shader</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>
<p>This constructor creates an invalid shader. </p>

</div>
</div>
<a class="anchor" id="a4bac6cc8b046ecd8fb967c145a2380e6"></a><!-- doxytag: member="sf::Shader::~Shader" ref="a4bac6cc8b046ecd8fb967c145a2380e6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a4bac6cc8b046ecd8fb967c145a2380e6">sf::Shader::~Shader</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a09778f78afcbeb854d608c8dacd8ea30"></a><!-- doxytag: member="sf::Shader::bind" ref="a09778f78afcbeb854d608c8dacd8ea30" args="(const Shader *shader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a09778f78afcbeb854d608c8dacd8ea30">sf::Shader::bind</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d2b/classsf_1_1_shader.html">Shader</a> *&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bind a shader for rendering. </p>
<p>This function is not part of the graphics API, it mustn't be used when drawing SFML entities. It must be used only if you mix <a class="el" href="../../d6/d2b/classsf_1_1_shader.html" title="Shader class (vertex and fragment)">sf::Shader</a> with OpenGL code.</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="../../d6/d2b/classsf_1_1_shader.html" title="Shader class (vertex and fragment)">sf::Shader</a> s1, s2;
 ...
 <a class="code" href="../../d6/d2b/classsf_1_1_shader.html#a09778f78afcbeb854d608c8dacd8ea30" title="Bind a shader for rendering.">sf::Shader::bind</a>(&amp;s1);
 <span class="comment">// draw OpenGL stuff that use s1...</span>
 <a class="code" href="../../d6/d2b/classsf_1_1_shader.html#a09778f78afcbeb854d608c8dacd8ea30" title="Bind a shader for rendering.">sf::Shader::bind</a>(&amp;s2);
 <span class="comment">// draw OpenGL stuff that use s2...</span>
 <a class="code" href="../../d6/d2b/classsf_1_1_shader.html#a09778f78afcbeb854d608c8dacd8ea30" title="Bind a shader for rendering.">sf::Shader::bind</a>(NULL);
 <span class="comment">// draw OpenGL stuff that use no shader...</span>
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">shader</td><td><a class="el" href="../../d6/d2b/classsf_1_1_shader.html" title="Shader class (vertex and fragment)">Shader</a> to bind, can be null to use no shader </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc5f4c744f76e5c4cfa74d222b6eab11"></a><!-- doxytag: member="sf::Shader::bindTextures" ref="afc5f4c744f76e5c4cfa74d222b6eab11" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#afc5f4c744f76e5c4cfa74d222b6eab11">sf::Shader::bindTextures</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bind all the textures used by the shader. </p>
<p>This function each texture to a different unit, and updates the corresponding variables in the shader accordingly. </p>

</div>
</div>
<a class="anchor" id="a500c8e3b0901bdb272175467fdda80b9"></a><!-- doxytag: member="sf::Shader::compile" ref="a500c8e3b0901bdb272175467fdda80b9" args="(const char *vertexShaderCode, const char *fragmentShaderCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a500c8e3b0901bdb272175467fdda80b9">sf::Shader::compile</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>vertexShaderCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fragmentShaderCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compile the shader(s) and create the program. </p>
<p>If one of the arguments is NULL, the corresponding shader is not created.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexShaderCode</td><td>Source code of the vertex shader </td></tr>
    <tr><td class="paramname">fragmentShaderCode</td><td>Source code of the fragment shader</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True on success, false if any error happened </dd></dl>

</div>
</div>
<a class="anchor" id="a8e14d868ccf4d464a155eec58570434a"></a><!-- doxytag: member="sf::Shader::getParamLocation" ref="a8e14d868ccf4d464a155eec58570434a" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a8e14d868ccf4d464a155eec58570434a">sf::Shader::getParamLocation</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the location ID of a shader parameter. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the parameter to search</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Location ID of the parameter, or -1 if not found </dd></dl>

</div>
</div>
<a class="anchor" id="ad22474690bafe4a305c1b9826b1bd86a"></a><!-- doxytag: member="sf::Shader::isAvailable" ref="ad22474690bafe4a305c1b9826b1bd86a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#ad22474690bafe4a305c1b9826b1bd86a">sf::Shader::isAvailable</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell whether or not the system supports shaders. </p>
<p>This function should always be called before using the shader features. If it returns false, then any attempt to use <a class="el" href="../../d6/d2b/classsf_1_1_shader.html" title="Shader class (vertex and fragment)">sf::Shader</a> will fail.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if shaders are supported, false otherwise </dd></dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d6/d2b/classsf_1_1_shader_ad22474690bafe4a305c1b9826b1bd86a_icgraph.png" border="0" usemap="#d6/d2b/classsf_1_1_shader_ad22474690bafe4a305c1b9826b1bd86a_icgraph" alt=""/></div>
<map name="d6/d2b/classsf_1_1_shader_ad22474690bafe4a305c1b9826b1bd86a_icgraph" id="d6/d2b/classsf_1_1_shader_ad22474690bafe4a305c1b9826b1bd86a_icgraph">
<area shape="rect" id="node3" href="../../d6/d58/class_effect.html#a7f926c8c6b21664461745f4c62cf7d0b" title="Effect::load" alt="" coords="209,5,297,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a053a5632848ebaca2fcd8ba29abe9e6e"></a><!-- doxytag: member="sf::Shader::loadFromFile" ref="a053a5632848ebaca2fcd8ba29abe9e6e" args="(const std::string &amp;filename, Type type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a053a5632848ebaca2fcd8ba29abe9e6e">sf::Shader::loadFromFile</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#afaa1aa65e5de37b74d047da9def9f9b3">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load either the vertex or fragment shader from a file. </p>
<p>This function loads a single shader, either vertex or fragment, identified by the second argument. The source must be a text file containing a valid shader in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Path of the vertex or fragment shader file to load </td></tr>
    <tr><td class="paramname">type</td><td>Type of shader (vertex or fragment)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if loading succeeded, false if it failed</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#ac92d46bf71dff2d791117e4e472148aa" title="Load either the vertex or fragment shader from a source code in memory.">loadFromMemory</a>, <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a2ee1b130c0606e4f8bcdf65c1efc2a53" title="Load either the vertex or fragment shader from a custom stream.">loadFromStream</a> </dd></dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d6/d2b/classsf_1_1_shader_a053a5632848ebaca2fcd8ba29abe9e6e_icgraph.png" border="0" usemap="#d6/d2b/classsf_1_1_shader_a053a5632848ebaca2fcd8ba29abe9e6e_icgraph" alt=""/></div>
<map name="d6/d2b/classsf_1_1_shader_a053a5632848ebaca2fcd8ba29abe9e6e_icgraph" id="d6/d2b/classsf_1_1_shader_a053a5632848ebaca2fcd8ba29abe9e6e_icgraph">
<area shape="rect" id="node3" href="../../d6/db2/class_pixelate.html#a815d873c5d41fe57af715965b4f2fbbd" title="Pixelate::onLoad" alt="" coords="228,5,345,35"/><area shape="rect" id="node5" href="../../d2/de4/class_wave_blur.html#a7fea002e212a7bb88126b25b6bd57396" title="WaveBlur::onLoad" alt="" coords="223,59,351,88"/><area shape="rect" id="node7" href="../../d7/d7a/class_storm_blink.html#aaf78eaf05b23742e6b5f5c471b790cbe" title="StormBlink::onLoad" alt="" coords="219,112,355,141"/><area shape="rect" id="node9" href="../../d7/d77/class_edge.html#a85a432189d48b34f17f154d59814a7ed" title="Edge::onLoad" alt="" coords="236,165,337,195"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac9d7289966fcef562eeb92271c03e3dc"></a><!-- doxytag: member="sf::Shader::loadFromFile" ref="ac9d7289966fcef562eeb92271c03e3dc" args="(const std::string &amp;vertexShaderFilename, const std::string &amp;fragmentShaderFilename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a053a5632848ebaca2fcd8ba29abe9e6e">sf::Shader::loadFromFile</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vertexShaderFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fragmentShaderFilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load both the vertex and fragment shaders from files. </p>
<p>This function loads both the vertex and the fragment shaders. If one of them fails to load, the shader is left empty (the valid shader is unloaded). The sources must be text files containing valid shaders in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexShaderFilename</td><td>Path of the vertex shader file to load </td></tr>
    <tr><td class="paramname">fragmentShaderFilename</td><td>Path of the fragment shader file to load</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if loading succeeded, false if it failed</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#ac92d46bf71dff2d791117e4e472148aa" title="Load either the vertex or fragment shader from a source code in memory.">loadFromMemory</a>, <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a2ee1b130c0606e4f8bcdf65c1efc2a53" title="Load either the vertex or fragment shader from a custom stream.">loadFromStream</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac92d46bf71dff2d791117e4e472148aa"></a><!-- doxytag: member="sf::Shader::loadFromMemory" ref="ac92d46bf71dff2d791117e4e472148aa" args="(const std::string &amp;shader, Type type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#ac92d46bf71dff2d791117e4e472148aa">sf::Shader::loadFromMemory</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>shader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#afaa1aa65e5de37b74d047da9def9f9b3">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load either the vertex or fragment shader from a source code in memory. </p>
<p>This function loads a single shader, either vertex or fragment, identified by the second argument. The source code must be a valid shader in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">shader</td><td><a class="el" href="../../df/d84/classsf_1_1_string.html" title="Utility string class that automatically handles conversions between types and encodings.">String</a> containing the source code of the shader </td></tr>
    <tr><td class="paramname">type</td><td>Type of shader (vertex or fragment)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if loading succeeded, false if it failed</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a053a5632848ebaca2fcd8ba29abe9e6e" title="Load either the vertex or fragment shader from a file.">loadFromFile</a>, <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a2ee1b130c0606e4f8bcdf65c1efc2a53" title="Load either the vertex or fragment shader from a custom stream.">loadFromStream</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae34e94070d7547a890166b7993658a9b"></a><!-- doxytag: member="sf::Shader::loadFromMemory" ref="ae34e94070d7547a890166b7993658a9b" args="(const std::string &amp;vertexShader, const std::string &amp;fragmentShader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#ac92d46bf71dff2d791117e4e472148aa">sf::Shader::loadFromMemory</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vertexShader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fragmentShader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load both the vertex and fragment shaders from source codes in memory. </p>
<p>This function loads both the vertex and the fragment shaders. If one of them fails to load, the shader is left empty (the valid shader is unloaded). The sources must be valid shaders in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexShader</td><td><a class="el" href="../../df/d84/classsf_1_1_string.html" title="Utility string class that automatically handles conversions between types and encodings.">String</a> containing the source code of the vertex shader </td></tr>
    <tr><td class="paramname">fragmentShader</td><td><a class="el" href="../../df/d84/classsf_1_1_string.html" title="Utility string class that automatically handles conversions between types and encodings.">String</a> containing the source code of the fragment shader</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if loading succeeded, false if it failed</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a053a5632848ebaca2fcd8ba29abe9e6e" title="Load either the vertex or fragment shader from a file.">loadFromFile</a>, <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a2ee1b130c0606e4f8bcdf65c1efc2a53" title="Load either the vertex or fragment shader from a custom stream.">loadFromStream</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2ee1b130c0606e4f8bcdf65c1efc2a53"></a><!-- doxytag: member="sf::Shader::loadFromStream" ref="a2ee1b130c0606e4f8bcdf65c1efc2a53" args="(InputStream &amp;stream, Type type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a2ee1b130c0606e4f8bcdf65c1efc2a53">sf::Shader::loadFromStream</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d3f/classsf_1_1_input_stream.html">InputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#afaa1aa65e5de37b74d047da9def9f9b3">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load either the vertex or fragment shader from a custom stream. </p>
<p>This function loads a single shader, either vertex or fragment, identified by the second argument. The source code must be a valid shader in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Source stream to read from </td></tr>
    <tr><td class="paramname">type</td><td>Type of shader (vertex or fragment)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if loading succeeded, false if it failed</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a053a5632848ebaca2fcd8ba29abe9e6e" title="Load either the vertex or fragment shader from a file.">loadFromFile</a>, <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#ac92d46bf71dff2d791117e4e472148aa" title="Load either the vertex or fragment shader from a source code in memory.">loadFromMemory</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3b7958159ffb5596c4babc3052e35465"></a><!-- doxytag: member="sf::Shader::loadFromStream" ref="a3b7958159ffb5596c4babc3052e35465" args="(InputStream &amp;vertexShaderStream, InputStream &amp;fragmentShaderStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a2ee1b130c0606e4f8bcdf65c1efc2a53">sf::Shader::loadFromStream</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d3f/classsf_1_1_input_stream.html">InputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>vertexShaderStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/d3f/classsf_1_1_input_stream.html">InputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>fragmentShaderStream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load both the vertex and fragment shaders from custom streams. </p>
<p>This function loads both the vertex and the fragment shaders. If one of them fails to load, the shader is left empty (the valid shader is unloaded). The source codes must be valid shaders in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexShaderStream</td><td>Source stream to read the vertex shader from </td></tr>
    <tr><td class="paramname">fragmentShaderStream</td><td>Source stream to read the fragment shader from</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if loading succeeded, false if it failed</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a053a5632848ebaca2fcd8ba29abe9e6e" title="Load either the vertex or fragment shader from a file.">loadFromFile</a>, <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#ac92d46bf71dff2d791117e4e472148aa" title="Load either the vertex or fragment shader from a source code in memory.">loadFromMemory</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a47e4dd78f0752ae08664b4ee616db1cf"></a><!-- doxytag: member="sf::Shader::setParameter" ref="a47e4dd78f0752ae08664b4ee616db1cf" args="(const std::string &amp;name, float x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a47e4dd78f0752ae08664b4ee616db1cf">sf::Shader::setParameter</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change a float parameter of the shader. </p>
<p><em>name</em> is the name of the variable to change in the shader. The corresponding parameter in the shader must be a float (float GLSL type).</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> uniform <span class="keywordtype">float</span> myparam; <span class="comment">// this is the variable in the shader</span>
</pre></div> <div class="fragment"><pre class="fragment"> shader.setParameter(<span class="stringliteral">&quot;myparam&quot;</span>, 5.2f);
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the parameter in the shader </td></tr>
    <tr><td class="paramname">x</td><td>Value to assign </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d6/d2b/classsf_1_1_shader_a47e4dd78f0752ae08664b4ee616db1cf_icgraph.png" border="0" usemap="#d6/d2b/classsf_1_1_shader_a47e4dd78f0752ae08664b4ee616db1cf_icgraph" alt=""/></div>
<map name="d6/d2b/classsf_1_1_shader_a47e4dd78f0752ae08664b4ee616db1cf_icgraph" id="d6/d2b/classsf_1_1_shader_a47e4dd78f0752ae08664b4ee616db1cf_icgraph">
<area shape="rect" id="node3" href="../../d6/db2/class_pixelate.html#a815d873c5d41fe57af715965b4f2fbbd" title="Pixelate::onLoad" alt="" coords="239,5,356,35"/><area shape="rect" id="node5" href="../../d6/db2/class_pixelate.html#a78dd551e6e8cf39326acb1131b4964fe" title="Pixelate::onUpdate" alt="" coords="231,59,364,88"/><area shape="rect" id="node7" href="../../d2/de4/class_wave_blur.html#afbc71110feb1a9638b15be91bffd9ec6" title="WaveBlur::onUpdate" alt="" coords="227,112,368,141"/><area shape="rect" id="node9" href="../../d7/d7a/class_storm_blink.html#ab679ebd3ef1b7a1b8fbd579cd7c87fce" title="StormBlink::onUpdate" alt="" coords="223,165,372,195"/><area shape="rect" id="node11" href="../../d7/d77/class_edge.html#a85a432189d48b34f17f154d59814a7ed" title="Edge::onLoad" alt="" coords="247,219,348,248"/><area shape="rect" id="node13" href="../../d7/d77/class_edge.html#a7a803416ae1c07a17a7fb1bee8d4821c" title="Edge::onUpdate" alt="" coords="240,272,355,301"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab8d379f40810b8e3eadebee81aedd231"></a><!-- doxytag: member="sf::Shader::setParameter" ref="ab8d379f40810b8e3eadebee81aedd231" args="(const std::string &amp;name, float x, float y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a47e4dd78f0752ae08664b4ee616db1cf">sf::Shader::setParameter</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change a 2-components vector parameter of the shader. </p>
<p><em>name</em> is the name of the variable to change in the shader. The corresponding parameter in the shader must be a 2x1 vector (vec2 GLSL type).</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> uniform vec2 myparam; <span class="comment">// this is the variable in the shader</span>
</pre></div> <div class="fragment"><pre class="fragment"> shader.setParameter(<span class="stringliteral">&quot;myparam&quot;</span>, 5.2f, 6.0f);
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the parameter in the shader </td></tr>
    <tr><td class="paramname">x</td><td>First component of the value to assign </td></tr>
    <tr><td class="paramname">y</td><td>Second component of the value to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e36e044d6b8adca8339f40c5a4b1801"></a><!-- doxytag: member="sf::Shader::setParameter" ref="a7e36e044d6b8adca8339f40c5a4b1801" args="(const std::string &amp;name, float x, float y, float z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a47e4dd78f0752ae08664b4ee616db1cf">sf::Shader::setParameter</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change a 3-components vector parameter of the shader. </p>
<p><em>name</em> is the name of the variable to change in the shader. The corresponding parameter in the shader must be a 3x1 vector (vec3 GLSL type).</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> uniform vec3 myparam; <span class="comment">// this is the variable in the shader</span>
</pre></div> <div class="fragment"><pre class="fragment"> shader.setParameter(<span class="stringliteral">&quot;myparam&quot;</span>, 5.2f, 6.0f, -8.1f);
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the parameter in the shader </td></tr>
    <tr><td class="paramname">x</td><td>First component of the value to assign </td></tr>
    <tr><td class="paramname">y</td><td>Second component of the value to assign </td></tr>
    <tr><td class="paramname">z</td><td>Third component of the value to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb468f1bc2d26750b96b74f1e19027fb"></a><!-- doxytag: member="sf::Shader::setParameter" ref="aeb468f1bc2d26750b96b74f1e19027fb" args="(const std::string &amp;name, float x, float y, float z, float w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a47e4dd78f0752ae08664b4ee616db1cf">sf::Shader::setParameter</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change a 4-components vector parameter of the shader. </p>
<p><em>name</em> is the name of the variable to change in the shader. The corresponding parameter in the shader must be a 4x1 vector (vec4 GLSL type).</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> uniform vec4 myparam; <span class="comment">// this is the variable in the shader</span>
</pre></div> <div class="fragment"><pre class="fragment"> shader.setParameter(<span class="stringliteral">&quot;myparam&quot;</span>, 5.2f, 6.0f, -8.1f, 0.4f);
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the parameter in the shader </td></tr>
    <tr><td class="paramname">x</td><td>First component of the value to assign </td></tr>
    <tr><td class="paramname">y</td><td>Second component of the value to assign </td></tr>
    <tr><td class="paramname">z</td><td>Third component of the value to assign </td></tr>
    <tr><td class="paramname">w</td><td>Fourth component of the value to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ac473ece2c6fa26dc5032c07fd7288e"></a><!-- doxytag: member="sf::Shader::setParameter" ref="a3ac473ece2c6fa26dc5032c07fd7288e" args="(const std::string &amp;name, const Vector2f &amp;vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a47e4dd78f0752ae08664b4ee616db1cf">sf::Shader::setParameter</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/dd0/namespacesf.html#acf03098c2577b869e2fa6836cc48f1a0">Vector2f</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change a 2-components vector parameter of the shader. </p>
<p><em>name</em> is the name of the variable to change in the shader. The corresponding parameter in the shader must be a 2x1 vector (vec2 GLSL type).</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> uniform vec2 myparam; <span class="comment">// this is the variable in the shader</span>
</pre></div> <div class="fragment"><pre class="fragment"> shader.setParameter(<span class="stringliteral">&quot;myparam&quot;</span>, <a class="code" href="../../d3/d71/classsf_1_1_vector2.html">sf::Vector2f</a>(5.2f, 6.0f));
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the parameter in the shader </td></tr>
    <tr><td class="paramname">vector</td><td>Vector to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a87d4a0c6dc70ae68aecc0dda3f343c07"></a><!-- doxytag: member="sf::Shader::setParameter" ref="a87d4a0c6dc70ae68aecc0dda3f343c07" args="(const std::string &amp;name, const Vector3f &amp;vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a47e4dd78f0752ae08664b4ee616db1cf">sf::Shader::setParameter</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/dd0/namespacesf.html#af97357d7d32e7d6a700d03be2f3b4811">Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change a 3-components vector parameter of the shader. </p>
<p><em>name</em> is the name of the variable to change in the shader. The corresponding parameter in the shader must be a 3x1 vector (vec3 GLSL type).</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> uniform vec3 myparam; <span class="comment">// this is the variable in the shader</span>
</pre></div> <div class="fragment"><pre class="fragment"> shader.setParameter(<span class="stringliteral">&quot;myparam&quot;</span>, <a class="code" href="../../d0/d2d/classsf_1_1_vector3.html" title="Utility template class for manipulating 3-dimensional vectors.">sf::Vector3f</a>(5.2f, 6.0f, -8.1f));
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the parameter in the shader </td></tr>
    <tr><td class="paramname">vector</td><td>Vector to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa8618119ed4399df3fd33e78ee96b4fc"></a><!-- doxytag: member="sf::Shader::setParameter" ref="aa8618119ed4399df3fd33e78ee96b4fc" args="(const std::string &amp;name, const Color &amp;color)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a47e4dd78f0752ae08664b4ee616db1cf">sf::Shader::setParameter</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/de5/classsf_1_1_color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change a color parameter of the shader. </p>
<p><em>name</em> is the name of the variable to change in the shader. The corresponding parameter in the shader must be a 4x1 vector (vec4 GLSL type).</p>
<p>It is important to note that the components of the color are normalized before being passed to the shader. Therefore, they are converted from range [0 .. 255] to range [0 .. 1]. For example, a sf::Color(255, 125, 0, 255) will be transformed to a vec4(1.0, 0.5, 0.0, 1.0) in the shader.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> uniform vec4 color; <span class="comment">// this is the variable in the shader</span>
</pre></div> <div class="fragment"><pre class="fragment"> shader.setParameter(<span class="stringliteral">&quot;color&quot;</span>, <a class="code" href="../../d8/de5/classsf_1_1_color.html" title="Utility class for manpulating RGBA colors.">sf::Color</a>(255, 128, 0, 255));
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the parameter in the shader </td></tr>
    <tr><td class="paramname">color</td><td><a class="el" href="../../d8/de5/classsf_1_1_color.html" title="Utility class for manpulating RGBA colors.">Color</a> to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a39c387cc30e249b22a0c478703b8cc9a"></a><!-- doxytag: member="sf::Shader::setParameter" ref="a39c387cc30e249b22a0c478703b8cc9a" args="(const std::string &amp;name, const sf::Transform &amp;transform)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a47e4dd78f0752ae08664b4ee616db1cf">sf::Shader::setParameter</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/d49/classsf_1_1_transform.html">sf::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change a matrix parameter of the shader. </p>
<p><em>name</em> is the name of the variable to change in the shader. The corresponding parameter in the shader must be a 4x4 matrix (mat4 GLSL type).</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> uniform mat4 matrix; <span class="comment">// this is the variable in the shader</span>
</pre></div> <div class="fragment"><pre class="fragment"> <a class="code" href="../../d4/d49/classsf_1_1_transform.html" title="Define a 3x3 transform matrix.">sf::Transform</a> transform;
 transform.<a class="code" href="../../d4/d49/classsf_1_1_transform.html#ab54f6c8070cc05e2afcb3145fbf4395a" title="Combine the current transform with a translation.">translate</a>(5, 10);
 shader.setParameter(<span class="stringliteral">&quot;matrix&quot;</span>, transform);
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the parameter in the shader </td></tr>
    <tr><td class="paramname">transform</td><td><a class="el" href="../../d4/d49/classsf_1_1_transform.html" title="Define a 3x3 transform matrix.">Transform</a> to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f58ab5c0a1084f238dfcec86602daa1"></a><!-- doxytag: member="sf::Shader::setParameter" ref="a7f58ab5c0a1084f238dfcec86602daa1" args="(const std::string &amp;name, const Texture &amp;texture)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a47e4dd78f0752ae08664b4ee616db1cf">sf::Shader::setParameter</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/d96/classsf_1_1_texture.html">Texture</a> &amp;&#160;</td>
          <td class="paramname"><em>texture</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change a texture parameter of the shader. </p>
<p><em>name</em> is the name of the variable to change in the shader. The corresponding parameter in the shader must be a 2D texture (sampler2D GLSL type).</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> uniform sampler2D the_texture; <span class="comment">// this is the variable in the shader</span>
</pre></div> <div class="fragment"><pre class="fragment"> <a class="code" href="../../d4/d96/classsf_1_1_texture.html" title="Image living on the graphics card that can be used for drawing.">sf::Texture</a> texture;
 ...
 shader.setParameter(<span class="stringliteral">&quot;the_texture&quot;</span>, texture);
</pre></div><p> It is important to note that <em>texture</em> must remain alive as long as the shader uses it, no copy is made internally.</p>
<p>To use the texture of the object being draw, which cannot be known in advance, you can pass the special value <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#ac84c7953eec2e19358ea6e2cc5385b8d">sf::Shader::CurrentTexture</a>: </p>
<div class="fragment"><pre class="fragment"> shader.setParameter(<span class="stringliteral">&quot;the_texture&quot;</span>, <a class="code" href="../../d6/d2b/classsf_1_1_shader.html#ac84c7953eec2e19358ea6e2cc5385b8d">sf::Shader::CurrentTexture</a>).
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the texture in the shader </td></tr>
    <tr><td class="paramname">texture</td><td><a class="el" href="../../d4/d96/classsf_1_1_texture.html" title="Image living on the graphics card that can be used for drawing.">Texture</a> to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af06b4cba0bab915fa01032b063909044"></a><!-- doxytag: member="sf::Shader::setParameter" ref="af06b4cba0bab915fa01032b063909044" args="(const std::string &amp;name, CurrentTextureType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a47e4dd78f0752ae08664b4ee616db1cf">sf::Shader::setParameter</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d0d/structsf_1_1_shader_1_1_current_texture_type.html">CurrentTextureType</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change a texture parameter of the shader. </p>
<p>This overload maps a shader texture variable to the texture of the object being drawn, which cannot be known in advance. The second argument must be <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#ac84c7953eec2e19358ea6e2cc5385b8d">sf::Shader::CurrentTexture</a>. The corresponding parameter in the shader must be a 2D texture (sampler2D GLSL type).</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> uniform sampler2D current; <span class="comment">// this is the variable in the shader</span>
</pre></div> <div class="fragment"><pre class="fragment"> shader.setParameter(<span class="stringliteral">&quot;current&quot;</span>, <a class="code" href="../../d6/d2b/classsf_1_1_shader.html#ac84c7953eec2e19358ea6e2cc5385b8d">sf::Shader::CurrentTexture</a>);
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the texture in the shader </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ac84c7953eec2e19358ea6e2cc5385b8d"></a><!-- doxytag: member="sf::Shader::CurrentTexture" ref="ac84c7953eec2e19358ea6e2cc5385b8d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d0d/structsf_1_1_shader_1_1_current_texture_type.html">CurrentTextureType</a> <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#ac84c7953eec2e19358ea6e2cc5385b8d">sf::Shader::CurrentTexture</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5d7b43495def6cc6bd91b6c5d167a485"></a><!-- doxytag: member="sf::Shader::m_currentTexture" ref="a5d7b43495def6cc6bd91b6c5d167a485" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a5d7b43495def6cc6bd91b6c5d167a485">sf::Shader::m_currentTexture</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Location of the current texture in the shader. </p>

</div>
</div>
<a class="anchor" id="a856d4fd949fcd1c0a54c77d7fb8f0084"></a><!-- doxytag: member="sf::Shader::m_params" ref="a856d4fd949fcd1c0a54c77d7fb8f0084" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a6934cc8c84c37d55db0a126ddb274abf">ParamTable</a> <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a856d4fd949fcd1c0a54c77d7fb8f0084">sf::Shader::m_params</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parameters location cache. </p>

</div>
</div>
<a class="anchor" id="a72169743cfd7206fd49759f705a15466"></a><!-- doxytag: member="sf::Shader::m_shaderProgram" ref="a72169743cfd7206fd49759f705a15466" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a72169743cfd7206fd49759f705a15466">sf::Shader::m_shaderProgram</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>OpenGL identifier for the program. </p>

</div>
</div>
<a class="anchor" id="a3daecf04a0045a1d7445959432b5a52f"></a><!-- doxytag: member="sf::Shader::m_textures" ref="a3daecf04a0045a1d7445959432b5a52f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a9a60c773571550fd54a394d4ce83f4a3">TextureTable</a> <a class="el" href="../../d6/d2b/classsf_1_1_shader.html#a3daecf04a0045a1d7445959432b5a52f">sf::Shader::m_textures</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="../../d4/d96/classsf_1_1_texture.html" title="Image living on the graphics card that can be used for drawing.">Texture</a> variables in the shader, mapped to their location. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="../../d2/d73/_shader_8hpp_source.html">Shader.hpp</a></li>
</ul>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="../../d4/dd0/namespacesf.html">sf</a>      </li>
      <li class="navelem"><a class="el" href="../../d6/d2b/classsf_1_1_shader.html">Shader</a>      </li>

    <li class="footer">Generated on Fri Aug 16 2013 10:48:56 for SaC2 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
